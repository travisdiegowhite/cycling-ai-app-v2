import React, { useState } from 'react';
import {
  Card,
  Button,
  Group,
  Stack,
  TextInput,
  Textarea,
  Text,
  Divider,
  Alert,
  Modal,
  LoadingOverlay,
} from '@mantine/core';
import {
  Save,
  Download,
  Share2,
  AlertCircle,
  CheckCircle,
} from 'lucide-react';
import { useAuth } from '../contexts/AuthContext';
import { supabase } from '../supabase';
import { pointsToGPX } from '../utils/gpx';
import toast from 'react-hot-toast';

const AIRouteActions = ({ route, onSaved }) => {
  const { user } = useAuth();
  const [saveModalOpen, setSaveModalOpen] = useState(false);
  const [routeName, setRouteName] = useState(route?.name || '');
  const [routeDescription, setRouteDescription] = useState('');
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);

  // Check if route has valid data for saving/exporting
  const hasValidRoute = route && route.coordinates && route.coordinates.length >= 2;

  // Export GPX
  const exportGPX = () => {
    if (!hasValidRoute) {
      toast.error('No valid route to export');
      return;
    }

    try {
      const gpxData = pointsToGPX(route.coordinates, {
        name: route.name || routeName || 'AI Generated Route',
        creator: 'Cycling AI App'
      });

      const blob = new Blob([gpxData], { type: 'application/gpx+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${(route.name || routeName || 'ai_route').replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.gpx`;
      a.click();
      URL.revokeObjectURL(url);

      toast.success('GPX file downloaded successfully!');
    } catch (err) {
      console.error('Export failed:', err);
      toast.error('Failed to export GPX file');
    }
  };

  // Save route to database
  const saveRoute = async () => {
    if (!routeName.trim()) {
      toast.error('Please enter a route name');
      return;
    }

    if (!hasValidRoute) {
      toast.error('No valid route to save');
      return;
    }

    setSaving(true);
    setError(null);

    try {
      // Calculate basic stats
      const distanceKm = route.distance || calculateDistance(route.coordinates);
      const elevationGain = route.elevation_gain || 0;

      // Prepare track points
      const track_points = route.coordinates.map((coord, index) => ({
        order_index: index,
        longitude: coord[0],
        latitude: coord[1],
        elevation: null, // AI routes don't have elevation data initially
        cumulative_distance: 0, // Could be calculated if needed
      }));

      const routeData = {
        user_id: user.id,
        name: routeName.trim(),
        description: routeDescription.trim() || null,
        distance_km: distanceKm,
        elevation_gain_m: elevationGain,
        activity_type: 'Ride',
        source: 'ai_generated',
        metadata: {
          ai_prompt: route.prompt || '',
          ai_reasoning: route.reasoning || '',
          generated_at: new Date().toISOString(),
          route_type: route.routeType || 'loop',
          difficulty: route.difficulty || 'moderate',
        },
        track_points,
        recorded_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        has_gps_data: true,
      };

      console.log('Saving AI-generated route:', routeData);

      const { data, error: saveError } = await supabase
        .from('routes')
        .insert([routeData])
        .select()
        .single();

      if (saveError) throw saveError;

      console.log('Route saved successfully:', data);
      toast.success('Route saved successfully!');
      setSaveModalOpen(false);

      if (onSaved) {
        onSaved(data);
      }

    } catch (err) {
      console.error('Save failed:', err);
      setError(`Failed to save route: ${err.message}`);
      toast.error(`Save failed: ${err.message}`);
    } finally {
      setSaving(false);
    }
  };

  // Share route
  const shareRoute = () => {
    if (!hasValidRoute) {
      toast.error('No route to share');
      return;
    }

    // Create a shareable description
    const shareText = `Check out this AI-generated cycling route: ${route.name || 'Unnamed Route'}\n\nDistance: ${route.distance ? `${route.distance}km` : 'Unknown'}\n\nGenerated by Cycling AI`;

    if (navigator.share) {
      navigator.share({
        title: route.name || 'AI Generated Cycling Route',
        text: shareText,
        url: window.location.href,
      }).catch(err => console.log('Share failed:', err));
    } else {
      navigator.clipboard.writeText(`${shareText}\n\n${window.location.href}`);
      toast.success('Route details copied to clipboard!');
    }
  };

  // Basic distance calculation for routes without distance
  const calculateDistance = (coordinates) => {
    if (!coordinates || coordinates.length < 2) return 0;

    let distance = 0;
    for (let i = 1; i < coordinates.length; i++) {
      distance += haversineDistance(
        coordinates[i-1][1], coordinates[i-1][0],
        coordinates[i][1], coordinates[i][0]
      );
    }
    return distance / 1000; // Convert to km
  };

  const haversineDistance = (lat1, lon1, lat2, lon2) => {
    const R = 6371000; // Earth's radius in meters
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  if (!hasValidRoute) {
    return (
      <Card p="md" mt="md">
        <Alert icon={<AlertCircle size={16} />} color="gray" variant="light">
          <Text size="sm">Generate a route to enable save and export options</Text>
        </Alert>
      </Card>
    );
  }

  return (
    <>
      <Card p="md" mt="md">
        <Stack spacing="md">
          <Group justify="space-between" align="center">
            <Text fw={600} size="sm">Route Actions</Text>
            <CheckCircle size={16} color="green" />
          </Group>

          <Divider />

          <Stack spacing="xs">
            <Button
              leftSection={<Save size={16} />}
              variant="filled"
              onClick={() => setSaveModalOpen(true)}
              fullWidth
            >
              Save Route
            </Button>

            <Button
              leftSection={<Download size={16} />}
              variant="outline"
              onClick={exportGPX}
              fullWidth
            >
              Export GPX
            </Button>

            <Button
              leftSection={<Share2 size={16} />}
              variant="light"
              onClick={shareRoute}
              fullWidth
            >
              Share Route
            </Button>
          </Stack>

          {route.distance && (
            <Text size="xs" c="dimmed" ta="center">
              {route.distance}km â€¢ {route.routeType || 'Generated Route'}
            </Text>
          )}
        </Stack>
      </Card>

      {/* Save Modal */}
      <Modal
        opened={saveModalOpen}
        onClose={() => setSaveModalOpen(false)}
        title="Save AI Generated Route"
        size="md"
      >
        <LoadingOverlay visible={saving} />

        <Stack spacing="md">
          <TextInput
            label="Route Name"
            placeholder="Enter a name for your route"
            value={routeName}
            onChange={(e) => setRouteName(e.target.value)}
            required
          />

          <Textarea
            label="Description (Optional)"
            placeholder="Add notes about this route..."
            value={routeDescription}
            onChange={(e) => setRouteDescription(e.target.value)}
            minRows={3}
          />

          {route.prompt && (
            <Alert color="blue" variant="light">
              <Text size="sm" fw={500}>AI Prompt:</Text>
              <Text size="sm">{route.prompt}</Text>
            </Alert>
          )}

          {error && (
            <Alert icon={<AlertCircle size={16} />} color="red">
              {error}
            </Alert>
          )}

          <Group justify="flex-end" mt="md">
            <Button
              variant="subtle"
              onClick={() => setSaveModalOpen(false)}
            >
              Cancel
            </Button>
            <Button
              onClick={saveRoute}
              loading={saving}
              leftSection={<Save size={16} />}
            >
              Save Route
            </Button>
          </Group>
        </Stack>
      </Modal>
    </>
  );
};

export default AIRouteActions;